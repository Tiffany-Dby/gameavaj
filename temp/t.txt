This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-04-15T07:19:47.671Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.editorconfig
.gitattributes
.gitignore
assets/.gitkeep
build.gradle
core/build.gradle
core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/Enemy.java
core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyController.java
core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyFactory.java
core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyRenderer.java
core/src/main/java/fr/sup_de_vinci/gameavaj/Main.java
core/src/main/java/fr/sup_de_vinci/gameavaj/map/MapManager.java
core/src/main/java/fr/sup_de_vinci/gameavaj/Player.java
core/src/main/java/fr/sup_de_vinci/gameavaj/screen/FirstScreen.java
core/src/main/java/fr/sup_de_vinci/gameavaj/utils/Direction.java
gradle.properties
gradle/gradle-daemon-jvm.properties
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
lwjgl3/build.gradle
lwjgl3/nativeimage.gradle
lwjgl3/src/main/java/fr/sup_de_vinci/gameavaj/lwjgl3/Lwjgl3Launcher.java
lwjgl3/src/main/java/fr/sup_de_vinci/gameavaj/lwjgl3/StartupHelper.java
README.md
settings.gradle

================================================================
Files
================================================================

================
File: .editorconfig
================
# https://editorconfig.org
root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{java,scala,groovy,kt,kts}]
indent_size = 4

[*.gradle]
indent_size = 2

[*.md]
trim_trailing_whitespace = false

================
File: .gitattributes
================
* text=auto eol=lf
*.bat text=auto eol=crlf

================
File: .gitignore
================
## Gradle:
.gradle/
gradle-app.setting
/build/
/android/build/
/core/build/
/lwjgl2/build/
/lwjgl3/build/
/html/build/
/teavm/build/
/ios/build/
/ios-moe/build/
/headless/build/
/server/build/
/shared/build/

## Java:
*.class
*.war
*.ear
hs_err_pid*
.attach_pid*

## Android:
/android/libs/armeabi-v7a/
/android/libs/arm64-v8a/
/android/libs/x86/
/android/libs/x86_64/
/android/gen/
/android/out/
local.properties
com_crashlytics_export_strings.xml

## Robovm:
/ios/robovm-build/

## iOS:
/ios/xcode/*.xcodeproj/*
!/ios/xcode/*.xcodeproj/xcshareddata
!/ios/xcode/*.xcodeproj/project.pbxproj
/ios/xcode/native/
/ios/IOSLauncher.app
/ios/IOSLauncher.app.dSYM

## GWT:
/html/war/
/html/gwt-unitCache/
.apt_generated/
/html/war/WEB-INF/deploy/
/html/war/WEB-INF/classes/
.gwt/
gwt-unitCache/
www-test/
.gwt-tmp/

## TeaVM:
# Not sure yet...

## IntelliJ, Android Studio:
.idea/
*.ipr
*.iws
*.iml

## Eclipse:
.classpath
.project
.metadata/
/android/bin/
/core/bin/
/lwjgl2/bin/
/lwjgl3/bin/
/html/bin/
/teavm/bin/
/ios/bin/
/ios-moe/bin/
/headless/bin/
/server/bin/
/shared/bin/
*.tmp
*.bak
*.swp
*~.nib
.settings/
.loadpath
.externalToolBuilders/
*.launch


## NetBeans:

/nbproject/private/
/android/nbproject/private/
/core/nbproject/private/
/lwjgl2/nbproject/private/
/lwjgl3/nbproject/private/
/html/nbproject/private/
/teavm/nbproject/private/
/ios/nbproject/private/
/ios-moe/nbproject/private/
/headless/nbproject/private/
/server/nbproject/private/
/shared/nbproject/private/

/nbbuild/
/android/nbbuild/
/core/nbbuild/
/lwjgl2/nbbuild/
/lwjgl3/nbbuild/
/html/nbbuild/
/teavm/nbbuild/
/ios/nbbuild/
/ios-moe/nbbuild/
/headless/nbbuild/
/server/nbbuild/
/shared/nbbuild/

/dist/
/android/dist/
/core/dist/
/lwjgl2/dist/
/lwjgl3/dist/
/html/dist/
/teavm/dist/
/ios/dist/
/ios-moe/dist/
/headless/dist/
/server/dist/
/shared/dist/

/nbdist/
/android/nbdist/
/core/nbdist/
/lwjgl2/nbdist/
/lwjgl3/nbdist/
/html/nbdist/
/teavm/nbdist/
/ios/nbdist/
/ios-moe/nbdist/
/headless/nbdist/
/server/nbdist/
/shared/nbdist/

nbactions.xml
nb-configuration.xml

## OS-Specific:
.DS_Store
Thumbs.db

## Miscellaneous:
*~
*.*#
*#*#
/.kotlin/
/assets/assets.txt

## Special cases:

## There is a resource-config.json file generated by nativeimage.gradle if you use Graal Native Image.
## Some usage may need extra resource configuration in a different file with the same name.
## You could also add that configuration to the text in nativeimage.gradle .
## You should delete or comment out the next line if you have configuration in a different resource-config.json .
**/resource-config.json

================
File: assets/.gitkeep
================
This file can be deleted if there are any other files present in this folder.
It is only here to ensure this folder is added to Git, instead of being
ignored because it is empty.

================
File: build.gradle
================
buildscript {
  repositories {
    mavenCentral()
    maven { url 'https://s01.oss.sonatype.org' }
    gradlePluginPortal()
    mavenLocal()
    google()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies {


  }
}

allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'

  // This allows you to "Build and run using IntelliJ IDEA", an option in IDEA's Settings.
  idea {
    module {
      outputDir file('build/classes/java/main')
      testOutputDir file('build/classes/java/test')
    }
  }
}

configure(subprojects) {
  apply plugin: 'java-library'
  sourceCompatibility = 8

  // From https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/
  // The article can be helpful when using assets.txt in your project.
  tasks.register('generateAssetList') {
    inputs.dir("${project.rootDir}/assets/")
    // projectFolder/assets
    File assetsFolder = new File("${project.rootDir}/assets/")
    // projectFolder/assets/assets.txt
    File assetsFile = new File(assetsFolder, "assets.txt")
    // delete that file in case we've already created it
    assetsFile.delete()

    // iterate through all files inside that folder
    // convert it to a relative path
    // and append it to the file assets.txt
    fileTree(assetsFolder).collect { assetsFolder.relativePath(it) }.sort().each {
      assetsFile.append(it + "\n")
    }
  }
  processResources.dependsOn 'generateAssetList'

  compileJava {
    options.incremental = true
  }
}

subprojects {
  version = "$projectVersion"
  ext.appName = 'gameavaj'
  repositories {
    mavenCentral()
    maven { url 'https://s01.oss.sonatype.org' }
    // You may want to remove the following line if you have errors downloading dependencies.
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}

eclipse.project.name = 'gameavaj' + '-parent'

================
File: core/build.gradle
================
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
eclipse.project.name = appName + '-core'

dependencies {
  api "com.badlogicgames.ashley:ashley:$ashleyVersion"
  api "com.badlogicgames.box2dlights:box2dlights:$box2dlightsVersion"
  api "com.badlogicgames.gdx-controllers:gdx-controllers-core:$gdxControllersVersion"
  api "com.badlogicgames.gdx:gdx-ai:$aiVersion"
  api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
  api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
  api "com.badlogicgames.gdx:gdx:$gdxVersion"

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-annotations:$graalHelperVersion"
  }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/Enemy.java
================
package fr.sup_de_vinci.gameavaj.enemy;

import fr.sup_de_vinci.gameavaj.map.MapManager;
import fr.sup_de_vinci.gameavaj.utils.Direction;

public class Enemy {

    private float x, y;
    private Direction direction;
    private float speed;

    public Enemy(float x, float y, Direction direction, float speed) {
        this.x = x;
        this.y = y;
        this.direction = direction;
        this.speed = speed;
    }

    public int getCellX() {
        return (int)(x / MapManager.TILE_SIZE);
    }

    public int getCellY() {
        return (int)(y / MapManager.TILE_SIZE);
    }

    public void snapToGrid() {
        this.x = Math.round(x / MapManager.TILE_SIZE) * MapManager.TILE_SIZE;
        this.y = Math.round(y / MapManager.TILE_SIZE) * MapManager.TILE_SIZE;
    }

    public boolean isCenteredOnTile() {
        float tolerance = 1f;
        float modX = x % MapManager.TILE_SIZE;
        float modY = y % MapManager.TILE_SIZE;
        return Math.abs(modX) < tolerance && Math.abs(modY) < tolerance;
    }

    public void move(float dx, float dy) {
        this.x += dx;
        this.y += dy;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getSpeed() {
        return speed;
    }

    public Direction getDirection() {
        return direction;
    }

    public void setDirection(Direction direction) {
        this.direction = direction;
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyController.java
================
package fr.sup_de_vinci.gameavaj.enemy;

import fr.sup_de_vinci.gameavaj.map.MapManager;
import fr.sup_de_vinci.gameavaj.utils.Direction;

import java.util.*;

public class EnemyController {
    private final Enemy enemy;
    private final float speed = 100f;

    public EnemyController(Enemy enemy) {
        this.enemy = enemy;
        randomDirection();
    }

    public void update(float deltaTime) {
        if (enemy.isCenteredOnTile()) {
            chooseNewDirection();
        }

        if (!willHitWall(enemy.getDirection())) {
            float dx = getDX(enemy.getDirection()) * speed * deltaTime;
            float dy = getDY(enemy.getDirection()) * speed * deltaTime;
            enemy.move(dx, dy);
        } else {
            enemy.snapToGrid();
            enemy.setDirection(enemy.getDirection().getOpposite());
        }
    }

    private void chooseNewDirection() {
        List<Direction> options = new ArrayList<>();

        for (Direction dir : Direction.values()) {
            if (dir == enemy.getDirection().getOpposite()) continue;

            int nx = enemy.getCellX() + (int) getDX(dir);
            int ny = enemy.getCellY() + (int) getDY(dir);

            if (MapManager.isWalkable(nx, ny)) {
                options.add(dir);
            }
        }

        if (!options.isEmpty()) {
            Collections.shuffle(options);
            enemy.setDirection(options.get(0));
        } else {
            enemy.setDirection(enemy.getDirection().getOpposite());
        }
    }

    private boolean willHitWall(Direction dir) {
        int nextX = (int)((enemy.getX() + getDX(dir) * MapManager.TILE_SIZE) / MapManager.TILE_SIZE);
        int nextY = (int)((enemy.getY() + getDY(dir) * MapManager.TILE_SIZE) / MapManager.TILE_SIZE);
        return !MapManager.isWalkable(nextX, nextY);
    }

    private float getDX(Direction dir) {
        return dir == Direction.LEFT ? -1 : dir == Direction.RIGHT ? 1 : 0;
    }

    private float getDY(Direction dir) {
        return dir == Direction.UP ? 1 : dir == Direction.DOWN ? -1 : 0;
    }

    private void randomDirection() {
        List<Direction> dirs = Arrays.asList(Direction.values());
        Collections.shuffle(dirs);
        enemy.setDirection(dirs.get(0));
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyFactory.java
================
package fr.sup_de_vinci.gameavaj.enemy;

import java.util.Random;

import fr.sup_de_vinci.gameavaj.map.MapManager;
import fr.sup_de_vinci.gameavaj.utils.Direction;

public class EnemyFactory {

    public static Enemy spawnRandomEnemy() {
        Random random = new Random();

        int mapHeight = MapManager.MAP.length;
        int mapWidth = MapManager.MAP[0].length;

        int cellX, cellY;
        do {
            cellX = random.nextInt(mapWidth);
            cellY = random.nextInt(mapHeight);
        } while (!MapManager.isWalkable(cellX, cellY));

        float x = cellX * MapManager.TILE_SIZE;
        float y = cellY * MapManager.TILE_SIZE;
        Direction direction = Direction.values()[random.nextInt(Direction.values().length)];
        float speed = 100;

        return new Enemy(x, y, direction, speed);
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/enemy/EnemyRenderer.java
================
package fr.sup_de_vinci.gameavaj.enemy;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

public class EnemyRenderer {

    private Enemy enemy;
    private float stateTime = 0f;

    private Texture enemySheet;
    private Animation<TextureRegion> walkDown, walkUp, walkLeft, walkRight;

    public EnemyRenderer(Enemy enemy) {
        this.enemy = enemy;

        enemySheet = new Texture("enemy-walk.png");
        TextureRegion[][] tmpFrames = TextureRegion.split(enemySheet, 64, 64);
        walkDown = new Animation<>(0.1f, tmpFrames[0]);
        walkUp = new Animation<>(0.1f, tmpFrames[1]);
        walkLeft = new Animation<>(0.1f, tmpFrames[2]);
        walkRight = new Animation<>(0.1f, tmpFrames[3]);
    }

    public void draw(SpriteBatch batch, float deltaTime) {
        stateTime += deltaTime;

        Animation<TextureRegion> currentAnim = walkDown;

        switch (enemy.getDirection()) {
            case UP: currentAnim = walkUp; break;
            case DOWN: currentAnim = walkDown; break;
            case LEFT: currentAnim = walkLeft; break;
            case RIGHT: currentAnim = walkRight; break;
        }

        TextureRegion currentFrame = currentAnim.getKeyFrame(stateTime, true);
        batch.draw(currentFrame, enemy.getX(), enemy.getY());
    }

    public void dispose() {
        enemySheet.dispose();
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/Main.java
================
package fr.sup_de_vinci.gameavaj;

import com.badlogic.gdx.Game;

import fr.sup_de_vinci.gameavaj.screen.FirstScreen;

/** {@link com.badlogic.gdx.ApplicationListener} implementation shared by all platforms. */
public class Main extends Game {
    @Override
    public void create() {
        setScreen(new FirstScreen());
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/map/MapManager.java
================
package fr.sup_de_vinci.gameavaj.map;

public class MapManager {
    public static final int TILE_SIZE = 64;

    // 1 = mur, 0 = sol
    public static final int[][] MAP = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1},
        {1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1},
        {1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1},
        {1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1},
        {1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1},
        {1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1},
        {1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1},
        {1,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    };
    
    

    public static boolean isWalkable(int cellX, int cellY) {
        if (cellY < 0 || cellY >= MAP.length || cellX < 0 || cellX >= MAP[0].length) return false;
        return MAP[cellY][cellX] == 0;
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/Player.java
================
// package fr.sup_de_vinci.gameavaj;

// import com.badlogic.gdx.graphics.Texture;
// import com.badlogic.gdx.graphics.g2d.SpriteBatch;

// public class Player {
//     private Texture texture;
//     private float x, y;

//     public Player(float x, float y) {
//         this.x = x;
//         this.y = y;
//         texture = new Texture("player-walk.png"); 
//     }

//     public void draw(SpriteBatch batch) {
//         batch.draw(texture, x, y);
//     }

//     public void dispose() {
//         texture.dispose();
//     }
// }

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/screen/FirstScreen.java
================
package fr.sup_de_vinci.gameavaj.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.utils.viewport.FitViewport;

import fr.sup_de_vinci.gameavaj.enemy.Enemy;
import fr.sup_de_vinci.gameavaj.enemy.EnemyController;
import fr.sup_de_vinci.gameavaj.enemy.EnemyFactory;
import fr.sup_de_vinci.gameavaj.enemy.EnemyRenderer;
import fr.sup_de_vinci.gameavaj.map.MapManager;


public class FirstScreen implements Screen {

    private static final int NUM_ENEMIES = 3;
    private static final int CORRIDOR_SIZE = 40;

    private SpriteBatch batch;
    private ShapeRenderer shapeRenderer;
    private OrthographicCamera camera;
    private FitViewport viewport;

    private EnemyController[] enemyControllers;
    private EnemyRenderer[] enemyRenderers;

    @Override
    public void show() {
        batch = new SpriteBatch();
        shapeRenderer = new ShapeRenderer();
        camera = new OrthographicCamera();
        camera.zoom = 2f;

        viewport = new FitViewport(800, 600, camera);
        centerCameraOnMap();

        enemyControllers = new EnemyController[NUM_ENEMIES];
        enemyRenderers = new EnemyRenderer[NUM_ENEMIES];

        for (int i = 0; i < NUM_ENEMIES; i++) {
            Enemy enemy = EnemyFactory.spawnRandomEnemy();
            enemyControllers[i] = new EnemyController(enemy);
            enemyRenderers[i] = new EnemyRenderer(enemy);
        }
    }

    @Override
    public void render(float delta) {
        clearScreen();

        for (EnemyController controller : enemyControllers) {
            controller.update(delta);
        }

        drawMap();
        drawEnemies(delta);
    }

    private void clearScreen() {
        Gdx.gl.glClearColor(0.7f, 0.8f, 1f, 1f);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
    }

    private void drawMap() {
        shapeRenderer.setProjectionMatrix(camera.combined);

        // Fond
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        int offset = (MapManager.TILE_SIZE - CORRIDOR_SIZE) / 2;

        for (int y = 0; y < MapManager.MAP.length; y++) {
            for (int x = 0; x < MapManager.MAP[0].length; x++) {
                boolean isWall = MapManager.MAP[y][x] == 1;
                shapeRenderer.setColor(isWall ? Color.BLACK : Color.WHITE);
                shapeRenderer.rect(
                    x * MapManager.TILE_SIZE + (isWall ? 0 : offset),
                    y * MapManager.TILE_SIZE + (isWall ? 0 : offset),
                    isWall ? MapManager.TILE_SIZE : CORRIDOR_SIZE,
                    isWall ? MapManager.TILE_SIZE : CORRIDOR_SIZE
                );
            }
        }

        shapeRenderer.end();

        // Grille
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.GRAY);

        for (int y = 0; y < MapManager.MAP.length; y++) {
            for (int x = 0; x < MapManager.MAP[0].length; x++) {
                shapeRenderer.rect(
                    x * MapManager.TILE_SIZE,
                    y * MapManager.TILE_SIZE,
                    MapManager.TILE_SIZE,
                    MapManager.TILE_SIZE
                );
            }
        }

        shapeRenderer.end();
    }

    private void drawEnemies(float delta) {
        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        for (EnemyRenderer renderer : enemyRenderers) {
            renderer.draw(batch, delta);
        }
        batch.end();
    }

    private void centerCameraOnMap() {
        int mapWidth = MapManager.MAP[0].length * MapManager.TILE_SIZE;
        int mapHeight = MapManager.MAP.length * MapManager.TILE_SIZE;
        camera.position.set(mapWidth / 2f, mapHeight / 2f, 0);
        camera.update();
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true);
        centerCameraOnMap();
    }

    @Override public void pause() {}
    @Override public void resume() {}
    @Override public void hide() {}

    @Override
    public void dispose() {
        for (EnemyRenderer renderer : enemyRenderers) {
            renderer.dispose();
        }
        if (batch != null) batch.dispose();
        if (shapeRenderer != null) shapeRenderer.dispose();
    }
}

================
File: core/src/main/java/fr/sup_de_vinci/gameavaj/utils/Direction.java
================
package fr.sup_de_vinci.gameavaj.utils;

public enum Direction {
    UP, RIGHT, DOWN, LEFT;

    public Direction getOpposite() {
        switch (this) {
            case UP: return DOWN;
            case DOWN: return UP;
            case LEFT: return RIGHT;
            case RIGHT: return LEFT;
        }
        return this;
    }

    public Direction turnLeft() {
        switch (this) {
            case UP: return LEFT;
            case LEFT: return DOWN;
            case DOWN: return RIGHT;
            case RIGHT: return UP;
        }
        return this;
    }

    public Direction turnRight() {
        switch (this) {
            case UP: return RIGHT;
            case RIGHT: return DOWN;
            case DOWN: return LEFT;
            case LEFT: return UP;
        }
        return this;
    }
}

================
File: gradle.properties
================
org.gradle.daemon=false
org.gradle.jvmargs=-Xms512M -Xmx1G -Dfile.encoding=UTF-8 -Dconsole.encoding=UTF-8
org.gradle.configureondemand=false
aiVersion=1.8.2
ashleyVersion=1.7.4
box2dlightsVersion=1.5
gdxControllersVersion=2.2.3
enableGraalNative=false
graalHelperVersion=2.0.1
gdxVersion=1.13.1
projectVersion=1.0.0

================
File: gradle/gradle-daemon-jvm.properties
================
#This file is generated by updateDaemonJvm
toolchainUrl.FREE_BSD.AARCH64=https\://api.foojay.io/disco/v3.0/ids/538ec8b643622db586076dcc6de01496/redirect
toolchainUrl.FREE_BSD.X86_64=https\://api.foojay.io/disco/v3.0/ids/3c821b3d2a2ed31cd255a8836df5ca27/redirect
toolchainUrl.LINUX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/538ec8b643622db586076dcc6de01496/redirect
toolchainUrl.LINUX.X86_64=https\://api.foojay.io/disco/v3.0/ids/3c821b3d2a2ed31cd255a8836df5ca27/redirect
toolchainUrl.MAC_OS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/4eb299e08ff72ece03792f6745206490/redirect
toolchainUrl.MAC_OS.X86_64=https\://api.foojay.io/disco/v3.0/ids/240ef070840c3324981ae8cc2985a9e6/redirect
toolchainUrl.UNIX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/538ec8b643622db586076dcc6de01496/redirect
toolchainUrl.UNIX.X86_64=https\://api.foojay.io/disco/v3.0/ids/3c821b3d2a2ed31cd255a8836df5ca27/redirect
toolchainUrl.WINDOWS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/ad1096e6e0353fb5900e1a5ece7d864a/redirect
toolchainUrl.WINDOWS.X86_64=https\://api.foojay.io/disco/v3.0/ids/41f6d00ddc15a000f14896a6d3bfb1b8/redirect
toolchainVendor=BELLSOFT
toolchainVersion=17

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: lwjgl3/build.gradle
================
buildscript {
  repositories {
    gradlePluginPortal()
  }
  dependencies {
    classpath "io.github.fourlastor:construo:1.7.1"
    if(enableGraalNative == 'true') {
      classpath "org.graalvm.buildtools.native:org.graalvm.buildtools.native.gradle.plugin:0.9.28"
    }
  }
}
plugins {
  id "application"
}
apply plugin: 'io.github.fourlastor.construo'


import io.github.fourlastor.construo.Target

sourceSets.main.resources.srcDirs += [ rootProject.file('assets').path ]
mainClassName = 'fr.sup_de_vinci.gameavaj.lwjgl3.Lwjgl3Launcher'
application.setMainClass(mainClassName)
eclipse.project.name = appName + '-lwjgl3'
java.sourceCompatibility = 8
java.targetCompatibility = 8
if (JavaVersion.current().isJava9Compatible()) {
        compileJava.options.release.set(8)
}

dependencies {
  implementation "com.badlogicgames.gdx-controllers:gdx-controllers-desktop:$gdxControllersVersion"
  implementation "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
  implementation "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
  implementation "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
  implementation "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
  implementation project(':core')

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-backend-lwjgl3:$graalHelperVersion"
      implementation "io.github.berstanio:gdx-svmhelper-extension-box2d:$graalHelperVersion"
      implementation "io.github.berstanio:gdx-svmhelper-extension-freetype:$graalHelperVersion"

    }
}

def os = System.properties['os.name'].toLowerCase()

run {
  workingDir = rootProject.file('assets').path
// You can uncomment the next line if your IDE claims a build failure even when the app closed properly.
  //setIgnoreExitValue(true)

  if (os.contains('mac')) jvmArgs += "-XstartOnFirstThread"
}

jar {
// sets the name of the .jar file this produces to the name of the game or app, with the version after.
  archiveFileName.set("${appName}-${projectVersion}.jar")
// the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
  duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
  dependsOn configurations.runtimeClasspath
  from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
// these "exclude" lines remove some unnecessary duplicate files in the output JAR.
  exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
// setting the manifest makes the JAR runnable.
  manifest {
    attributes 'Main-Class': project.mainClassName
  }
// this last step may help on some OSes that need extra instruction to make runnable JARs.
  doLast {
    file(archiveFile).setExecutable(true, false)
  }
}

// Builds a JAR that only includes the files needed to run on macOS, not Windows or Linux.
// The file size for a Mac-only JAR is about 7MB smaller than a cross-platform JAR.
tasks.register("jarMac") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-mac.jar")
  jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dll", "**/*.so",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

// Builds a JAR that only includes the files needed to run on Linux, not Windows or macOS.
// The file size for a Linux-only JAR is about 5MB smaller than a cross-platform JAR.
tasks.register("jarLinux") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-linux.jar")
  jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**", "**/*.dll", "**/*.dylib",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

// Builds a JAR that only includes the files needed to run on Windows, not Linux or macOS.
// The file size for a Windows-only JAR is about 6MB smaller than a cross-platform JAR.
tasks.register("jarWin") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-win.jar")
  jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dylib", "**/*.so",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

construo {
    // name of the executable
    name.set(appName)
    // human-readable name, used for example in the `.app` name for macOS
    humanName.set(appName)
    // Optional, defaults to project version property
    version.set("$projectVersion")

    targets.configure {
      create("linuxX64", Target.Linux) {
        architecture.set(Target.Architecture.X86_64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.12%2B7/OpenJDK17U-jdk_x64_linux_hotspot_17.0.12_7.tar.gz")
      }
      create("macM1", Target.MacOs) {
        architecture.set(Target.Architecture.AARCH64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.12%2B7/OpenJDK17U-jdk_aarch64_mac_hotspot_17.0.12_7.tar.gz")
        // macOS needs an identifier
        identifier.set("fr.sup_de_vinci.gameavaj." + appName)
        // Optional: icon for macOS
        macIcon.set(project.file("icons/logo.icns"))
      }
      create("macX64", Target.MacOs) {
        architecture.set(Target.Architecture.X86_64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.12%2B7/OpenJDK17U-jdk_x64_mac_hotspot_17.0.12_7.tar.gz")
        // macOS needs an identifier
        identifier.set("fr.sup_de_vinci.gameavaj." + appName)
        // Optional: icon for macOS
        macIcon.set(project.file("icons/logo.icns"))
      }
      create("winX64", Target.Windows) {
        architecture.set(Target.Architecture.X86_64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.12%2B7/OpenJDK17U-jdk_x64_windows_hotspot_17.0.12_7.zip")
        // Uncomment the next line to show a console when the game runs, to print messages.
        //useConsole.set(true)
      }
    }
}

// Equivalent to the jar task; here for compatibility with gdx-setup.
tasks.register('dist') {
  dependsOn 'jar'
}

distributions {
  main {
    contents {
      into('libs') {
        project.configurations.runtimeClasspath.files.findAll { file ->
          file.getName() != project.tasks.jar.outputs.files.singleFile.name
        }.each { file ->
          exclude file.name
        }
      }
    }
  }
}

startScripts.dependsOn(':lwjgl3:jar')
startScripts.classpath = project.tasks.jar.outputs.files

if(enableGraalNative == 'true') {
  apply from: file("nativeimage.gradle")
}

================
File: lwjgl3/nativeimage.gradle
================
project(":lwjgl3") {
  apply plugin: "org.graalvm.buildtools.native"

  graalvmNative {
    binaries {
      main {
        imageName = appName
        mainClass = project.mainClassName
        requiredVersion = '23.0'
        buildArgs.add("-march=compatibility")
        jvmArgs.addAll("-Dfile.encoding=UTF8")
        sharedLibrary = false
        resources.autodetect()
      }
    }
  }

  run {
    doNotTrackState("Running the app should not be affected by Graal.")
  }

  // Modified from https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/ ; thanks again, Lyze!
  // This creates a resource-config.json file based on the contents of the assets folder (and the libGDX icons).
  // This file is used by Graal Native to embed those specific files.
  // This has to run before nativeCompile, so it runs at the start of an unrelated resource-handling command.
  generateResourcesConfigFile.doFirst {
    def assetsFolder = new File("${project.rootDir}/assets/")
    def lwjgl3 = project(':lwjgl3')
    def resFolder = new File("${lwjgl3.projectDir}/src/main/resources/META-INF/native-image/${lwjgl3.ext.appName}")
    resFolder.mkdirs()
    def resFile = new File(resFolder, "resource-config.json")
    resFile.delete()
    resFile.append(
            """{
  "resources":{
  "includes":[
    {
      "pattern": ".*(""")
    // This adds every filename in the assets/ folder to a pattern that adds those files as resources.
    fileTree(assetsFolder).each {
      // The backslash-Q and backslash-E escape the start and end of a literal string, respectively.
      resFile.append("\\\\Q${it.name}\\\\E|")
    }
    // We also match all of the window icon images this way and the font files that are part of libGDX.
    resFile.append(
            """libgdx.+\\\\.png|lsans.+)"
    }
  ]},
  "bundles":[]
}"""
    )
  }
}

================
File: lwjgl3/src/main/java/fr/sup_de_vinci/gameavaj/lwjgl3/Lwjgl3Launcher.java
================
package fr.sup_de_vinci.gameavaj.lwjgl3;

import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;
import fr.sup_de_vinci.gameavaj.Main;

/** Launches the desktop (LWJGL3) application. */
public class Lwjgl3Launcher {
    public static void main(String[] args) {
        if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
        createApplication();
    }

    private static Lwjgl3Application createApplication() {
        return new Lwjgl3Application(new Main(), getDefaultConfiguration());
    }

    private static Lwjgl3ApplicationConfiguration getDefaultConfiguration() {
        Lwjgl3ApplicationConfiguration configuration = new Lwjgl3ApplicationConfiguration();
        configuration.setTitle("gameavaj");
        //// Vsync limits the frames per second to what your hardware can display, and helps eliminate
        //// screen tearing. This setting doesn't always work on Linux, so the line after is a safeguard.
        configuration.useVsync(true);
        //// Limits FPS to the refresh rate of the currently active monitor, plus 1 to try to match fractional
        //// refresh rates. The Vsync setting above should limit the actual FPS to match the monitor.
        configuration.setForegroundFPS(Lwjgl3ApplicationConfiguration.getDisplayMode().refreshRate + 1);
        //// If you remove the above line and set Vsync to false, you can get unlimited FPS, which can be
        //// useful for testing performance, but can also be very stressful to some hardware.
        //// You may also need to configure GPU drivers to fully disable Vsync; this can cause screen tearing.

        configuration.setWindowedMode(640, 480);
        //// You can change these files; they are in lwjgl3/src/main/resources/ .
        //// They can also be loaded from the root of assets/ .
        configuration.setWindowIcon("libgdx128.png", "libgdx64.png", "libgdx32.png", "libgdx16.png");
        return configuration;
    }
}

================
File: lwjgl3/src/main/java/fr/sup_de_vinci/gameavaj/lwjgl3/StartupHelper.java
================
/*
 * Copyright 2020 damios
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//Note, the above license and copyright applies to this file only.

package fr.sup_de_vinci.gameavaj.lwjgl3;

import com.badlogic.gdx.Version;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3NativesLoader;
import org.lwjgl.system.macosx.LibC;
import org.lwjgl.system.macosx.ObjCRuntime;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;

import static org.lwjgl.system.JNI.invokePPP;
import static org.lwjgl.system.JNI.invokePPZ;
import static org.lwjgl.system.macosx.ObjCRuntime.objc_getClass;
import static org.lwjgl.system.macosx.ObjCRuntime.sel_getUid;

/**
 * Adds some utilities to ensure that the JVM was started with the
 * {@code -XstartOnFirstThread} argument, which is required on macOS for LWJGL 3
 * to function. Also helps on Windows when users have names with characters from
 * outside the Latin alphabet, a common cause of startup crashes.
 * <br>
 * <a href="https://jvm-gaming.org/t/starting-jvm-on-mac-with-xstartonfirstthread-programmatically/57547">Based on this java-gaming.org post by kappa</a>
 * @author damios
 */
public class StartupHelper {

    private static final String JVM_RESTARTED_ARG = "jvmIsRestarted";

    private StartupHelper() {
        throw new UnsupportedOperationException();
    }

    /**
     * Starts a new JVM if the application was started on macOS without the
     * {@code -XstartOnFirstThread} argument. This also includes some code for
     * Windows, for the case where the user's home directory includes certain
     * non-Latin-alphabet characters (without this code, most LWJGL3 apps fail
     * immediately for those users). Returns whether a new JVM was started and
     * thus no code should be executed.
     * <p>
     * <u>Usage:</u>
     *
     * <pre><code>
     * public static void main(String... args) {
     * 	if (StartupHelper.startNewJvmIfRequired(true)) return; // This handles macOS support and helps on Windows.
     * 	// after this is the actual main method code
     * }
     * </code></pre>
     *
     * @param redirectOutput
     *            whether the output of the new JVM should be rerouted to the
     *            old JVM, so it can be accessed in the same place; keeps the
     *            old JVM running if enabled
     * @return whether a new JVM was started and thus no code should be executed
     *         in this one
     */
    public static boolean startNewJvmIfRequired(boolean redirectOutput) {
        String osName = System.getProperty("os.name").toLowerCase();
        if (!osName.contains("mac")) {
            if (osName.contains("windows")) {
// Here, we are trying to work around an issue with how LWJGL3 loads its extracted .dll files.
// By default, LWJGL3 extracts to the directory specified by "java.io.tmpdir", which is usually the user's home.
// If the user's name has non-ASCII (or some non-alphanumeric) characters in it, that would fail.
// By extracting to the relevant "ProgramData" folder, which is usually "C:\ProgramData", we avoid this.
// We also temporarily change the "user.name" property to one without any chars that would be invalid.
// We revert our changes immediately after loading LWJGL3 natives.
                String programData = System.getenv("ProgramData");
                if(programData == null) programData = "C:\\Temp\\"; // if ProgramData isn't set, try some fallback.
                String prevTmpDir = System.getProperty("java.io.tmpdir", programData);
                String prevUser = System.getProperty("user.name", "libGDX_User");
                System.setProperty("java.io.tmpdir", programData + "/libGDX-temp");
                System.setProperty("user.name", ("User_" + prevUser.hashCode() + "_GDX" + Version.VERSION).replace('.', '_'));
                Lwjgl3NativesLoader.load();
                System.setProperty("java.io.tmpdir", prevTmpDir);
                System.setProperty("user.name", prevUser);
            }
            return false;
        }

        // There is no need for -XstartOnFirstThread on Graal native image
        if (!System.getProperty("org.graalvm.nativeimage.imagecode", "").isEmpty()) {
            return false;
        }

        // Checks if we are already on the main thread, such as from running via Construo.
        long objc_msgSend = ObjCRuntime.getLibrary().getFunctionAddress("objc_msgSend");
        long NSThread      = objc_getClass("NSThread");
        long currentThread = invokePPP(NSThread, sel_getUid("currentThread"), objc_msgSend);
        boolean isMainThread = invokePPZ(currentThread, sel_getUid("isMainThread"), objc_msgSend);
        if(isMainThread) return false;

        long pid = LibC.getpid();

        // check whether -XstartOnFirstThread is enabled
        if ("1".equals(System.getenv("JAVA_STARTED_ON_FIRST_THREAD_" + pid))) {
            return false;
        }

        // check whether the JVM was previously restarted
        // avoids looping, but most certainly leads to a crash
        if ("true".equals(System.getProperty(JVM_RESTARTED_ARG))) {
            System.err.println(
                    "There was a problem evaluating whether the JVM was started with the -XstartOnFirstThread argument.");
            return false;
        }

        // Restart the JVM with -XstartOnFirstThread
        ArrayList<String> jvmArgs = new ArrayList<>();
        String separator = System.getProperty("file.separator", "/");
        // The following line is used assuming you target Java 8, the minimum for LWJGL3.
        String javaExecPath = System.getProperty("java.home") + separator + "bin" + separator + "java";
        // If targeting Java 9 or higher, you could use the following instead of the above line:
        //String javaExecPath = ProcessHandle.current().info().command().orElseThrow();

        if (!(new File(javaExecPath)).exists()) {
            System.err.println(
                    "A Java installation could not be found. If you are distributing this app with a bundled JRE, be sure to set the -XstartOnFirstThread argument manually!");
            return false;
        }

        jvmArgs.add(javaExecPath);
        jvmArgs.add("-XstartOnFirstThread");
        jvmArgs.add("-D" + JVM_RESTARTED_ARG + "=true");
        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());
        jvmArgs.add("-cp");
        jvmArgs.add(System.getProperty("java.class.path"));
        String mainClass = System.getenv("JAVA_MAIN_CLASS_" + pid);
        if (mainClass == null) {
            StackTraceElement[] trace = Thread.currentThread().getStackTrace();
            if (trace.length > 0) {
                mainClass = trace[trace.length - 1].getClassName();
            } else {
                System.err.println("The main class could not be determined.");
                return false;
            }
        }
        jvmArgs.add(mainClass);

        try {
            if (!redirectOutput) {
                ProcessBuilder processBuilder = new ProcessBuilder(jvmArgs);
                processBuilder.start();
            } else {
                Process process = (new ProcessBuilder(jvmArgs))
                        .redirectErrorStream(true).start();
                BufferedReader processOutput = new BufferedReader(
                        new InputStreamReader(process.getInputStream()));
                String line;

                while ((line = processOutput.readLine()) != null) {
                    System.out.println(line);
                }

                process.waitFor();
            }
        } catch (Exception e) {
            System.err.println("There was a problem restarting the JVM");
            e.printStackTrace();
        }

        return true;
    }

    /**
     * Starts a new JVM if the application was started on macOS without the
     * {@code -XstartOnFirstThread} argument. Returns whether a new JVM was
     * started and thus no code should be executed. Redirects the output of the
     * new JVM to the old one.
     * <p>
     * <u>Usage:</u>
     *
     * <pre>
     * public static void main(String... args) {
     * 	if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
     * 	// the actual main method code
     * }
     * </pre>
     *
     * @return whether a new JVM was started and thus no code should be executed
     *         in this one
     */
    public static boolean startNewJvmIfRequired() {
        return startNewJvmIfRequired(true);
    }
}

================
File: README.md
================
# gameavaj

A [libGDX](https://libgdx.com/) project generated with [gdx-liftoff](https://github.com/libgdx/gdx-liftoff).

This project was generated with a template including simple application launchers and a main class extending `Game` that sets the first screen.

## Platforms

- `core`: Main module with the application logic shared by all platforms.
- `lwjgl3`: Primary desktop platform using LWJGL3; was called 'desktop' in older docs.

## Gradle

This project uses [Gradle](https://gradle.org/) to manage dependencies.
The Gradle wrapper was included, so you can run Gradle tasks using `gradlew.bat` or `./gradlew` commands.
Useful Gradle tasks and flags:

- `--continue`: when using this flag, errors will not stop the tasks from running.
- `--daemon`: thanks to this flag, Gradle daemon will be used to run chosen tasks.
- `--offline`: when using this flag, cached dependency archives will be used.
- `--refresh-dependencies`: this flag forces validation of all dependencies. Useful for snapshot versions.
- `build`: builds sources and archives of every project.
- `cleanEclipse`: removes Eclipse project data.
- `cleanIdea`: removes IntelliJ project data.
- `clean`: removes `build` folders, which store compiled classes and built archives.
- `eclipse`: generates Eclipse project data.
- `idea`: generates IntelliJ project data.
- `lwjgl3:jar`: builds application's runnable jar, which can be found at `lwjgl3/build/libs`.
- `lwjgl3:run`: starts the application.
- `test`: runs unit tests (if any).

Note that most tasks that are not specific to a single project can be run with `name:` prefix, where the `name` should be replaced with the ID of a specific project.
For example, `core:clean` removes `build` folder only from the `core` project.

================
File: settings.gradle
================
plugins {
  // Applies the foojay-resolver plugin to allow automatic download of JDKs.
  id("org.gradle.toolchains.foojay-resolver-convention") version "0.9.0"
}
// A list of which subprojects to load as part of the same larger project.
// You can remove Strings from the list and reload the Gradle project
// if you want to temporarily disable a subproject.
include 'core', 'lwjgl3'



================================================================
End of Codebase
================================================================
